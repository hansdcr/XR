# visionOS 房间设计器 - 迭代计划详解

## 如何使用本文档

每个迭代包含：
- **目标**: 本次迭代要实现的功能
- **新建/修改文件**: 涉及的文件
- **方法列表**: 要实现的方法（按顺序）
- **代码要点**: 关键代码片段和说明
- **测试验证**: 如何验证功能正确
- **学习重点**: 本迭代的关键知识点

每完成一个迭代，建议：
1. 运行并测试代码
2. 理解每一行代码的作用
3. 与 Claude 讨论遇到的问题
4. 在理解透彻后再进行下一个迭代

---

# 阶段1: 基础架构

## 迭代 1: 创建项目基础结构

### 目标
创建 visionOS 应用的入口点，设置基本的 App 结构

### 新建文件
- `RoomDesignerApp.swift`

### 方法列表
1. `RoomDesignerApp.body` - App 的主体结构

### 代码要点

**RoomDesignerApp.swift**:
```swift
import SwiftUI

@main
struct RoomDesignerApp: App {
    var body: some Scene {
        WindowGroup {
            Text("Room Designer")
                .font(.title)
        }
    }
}
```

### 测试验证
- 运行应用，看到一个窗口显示 "Room Designer"

### 学习重点
- `@main` 标记应用入口点
- visionOS 的 `App` 协议
- `WindowGroup` 场景类型
- visionOS 应用最基本的结构

---

## 迭代 2: 创建主视图

### 目标
创建主视图，为后续功能预留 UI 结构

### 新建文件
- `ContentView.swift`

### 方法列表
1. `ContentView.body` - 主视图布局

### 代码要点

**ContentView.swift**:
```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack(spacing: 20) {
            Text("房间设计器")
                .font(.largeTitle)

            Text("准备开始")
                .font(.headline)
                .foregroundStyle(.secondary)
        }
        .padding()
    }
}
```

**更新 RoomDesignerApp.swift**:
```swift
WindowGroup {
    ContentView()
}
```

### 测试验证
- 看到带有标题和副标题的界面

### 学习重点
- SwiftUI 基础布局（VStack）
- visionOS 的文字样式
- View 协议

---

## 迭代 3: 添加状态管理类

### 目标
创建应用的状态管理类，为后续功能提供数据支持

### 新建文件
- `AppState.swift`

### 方法列表
1. `AppState` 类定义
2. `init()` - 初始化方法

### 代码要点

**AppState.swift**:
```swift
import Foundation
import Observation

@Observable
@MainActor
class AppState {
    // 是否在沉浸式空间中
    var isImmersive = false

    init() {
        print("AppState initialized")
    }
}
```

### 测试验证
- 代码编译无错误

### 学习重点
- `@Observable` 宏（Swift 5.9+ 新特性）
- `@MainActor` 确保线程安全
- visionOS 的状态管理模式

---

## 迭代 4: 将状态注入视图

### 目标
将 AppState 连接到视图层，建立数据流

### 修改文件
- `RoomDesignerApp.swift`
- `ContentView.swift`

### 方法列表
无新方法（修改现有代码）

### 代码要点

**RoomDesignerApp.swift**:
```swift
@main
struct RoomDesignerApp: App {
    @State private var appState = AppState()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(appState)
        }
    }
}
```

**ContentView.swift**:
```swift
struct ContentView: View {
    @Environment(AppState.self) private var appState

    var body: some View {
        VStack(spacing: 20) {
            Text("房间设计器")
                .font(.largeTitle)

            // 显示当前状态
            Text(appState.isImmersive ? "沉浸模式" : "窗口模式")
                .font(.headline)
                .foregroundStyle(.secondary)
        }
        .padding()
    }
}
```

### 测试验证
- 界面显示 "窗口模式"

### 学习重点
- `@State` 在 App 层的使用
- `.environment()` 传递数据
- `@Environment` 接收数据
- visionOS 的数据流模式

---

## 迭代 5: 添加沉浸式空间定义

### 目标
添加沉浸式空间场景，为 3D 内容做准备

### 新建文件
- `ImmersiveView.swift`

### 修改文件
- `RoomDesignerApp.swift`

### 方法列表
1. `ImmersiveView.body` - 沉浸式视图（暂时为空）

### 代码要点

**ImmersiveView.swift**:
```swift
import SwiftUI

struct ImmersiveView: View {
    @Environment(AppState.self) private var appState

    var body: some View {
        Text("沉浸式空间")
            .font(.title)
    }
}
```

**RoomDesignerApp.swift**:
```swift
@main
struct RoomDesignerApp: App {
    @State private var appState = AppState()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(appState)
        }

        ImmersiveSpace(id: "ImmersiveSpace") {
            ImmersiveView()
                .environment(appState)
        }
    }
}
```

### 测试验证
- 代码编译无错误

### 学习重点
- `ImmersiveSpace` 场景类型
- 沉浸式空间的 ID 标识
- 多场景应用结构

---

## 迭代 6: 添加进入沉浸式空间的按钮

### 目标
实现窗口和沉浸式空间之间的切换

### 修改文件
- `ContentView.swift`

### 方法列表
1. `openImmersiveSpace()` - 打开沉浸式空间
2. `closeImmersiveSpace()` - 关闭沉浸式空间

### 代码要点

**ContentView.swift**:
```swift
import SwiftUI

struct ContentView: View {
    @Environment(AppState.self) private var appState
    @Environment(\.openImmersiveSpace) private var openImmersiveSpace
    @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace

    var body: some View {
        VStack(spacing: 20) {
            Text("房间设计器")
                .font(.largeTitle)

            if !appState.isImmersive {
                Button("进入沉浸式空间") {
                    Task {
                        await openImmersiveSpace()
                    }
                }
                .buttonStyle(.borderedProminent)
            } else {
                Button("退出沉浸式空间") {
                    Task {
                        await closeImmersiveSpace()
                    }
                }
                .buttonStyle(.bordered)
            }
        }
        .padding()
    }

    private func openImmersiveSpace() async {
        await openImmersiveSpace(id: "ImmersiveSpace")
        appState.isImmersive = true
    }

    private func closeImmersiveSpace() async {
        await dismissImmersiveSpace()
        appState.isImmersive = false
    }
}
```

### 测试验证
- 点击按钮可以打开/关闭沉浸式空间
- 按钮文字根据状态变化

### 学习重点
- `@Environment(\.openImmersiveSpace)` 环境值
- `@Environment(\.dismissImmersiveSpace)` 环境值
- async/await 异步操作
- Task 包装异步调用

---

# 阶段2: 静态3D内容

## 迭代 7: 创建 RealityView

### 目标
在沉浸式空间中创建第一个 RealityView，为 3D 内容做准备

### 修改文件
- `ImmersiveView.swift`

### 方法列表
1. 修改 `ImmersiveView.body` - 添加 RealityView

### 代码要点

**ImmersiveView.swift**:
```swift
import SwiftUI
import RealityKit

struct ImmersiveView: View {
    @Environment(AppState.self) private var appState

    var body: some View {
        RealityView { content in
            // 这里将添加 3D 内容
            print("RealityView created")
        }
    }
}
```

### 测试验证
- 进入沉浸式空间后，控制台打印 "RealityView created"
- 看到空的 3D 空间

### 学习重点
- `RealityView` 的基本结构
- RealityView 的 content 闭包
- RealityKit 的导入

---

## 迭代 8: 在 AppState 中创建根实体

### 目标
创建管理 3D 内容的根实体

### 修改文件
- `AppState.swift`

### 方法列表
1. 添加 `contentRoot` 属性
2. `setupContentEntity()` - 设置内容实体

### 代码要点

**AppState.swift**:
```swift
import Foundation
import Observation
import RealityKit

@Observable
@MainActor
class AppState {
    var isImmersive = false

    // 3D 内容的根实体
    let contentRoot = Entity()

    init() {
        print("AppState initialized")
        setupContentEntity()
    }

    func setupContentEntity() {
        contentRoot.name = "ContentRoot"
        print("Content entity setup complete")
    }
}
```

### 测试验证
- 控制台打印 "Content entity setup complete"

### 学习重点
- RealityKit 的 `Entity` 类
- 实体的命名
- 实体层级结构的根节点

---

## 迭代 9: 将根实体添加到 RealityView

### 目标
将 AppState 中的根实体添加到场景中

### 修改文件
- `ImmersiveView.swift`

### 方法列表
1. 修改 RealityView 闭包

### 代码要点

**ImmersiveView.swift**:
```swift
struct ImmersiveView: View {
    @Environment(AppState.self) private var appState

    var body: some View {
        RealityView { content in
            content.add(appState.contentRoot)
            print("Root entity added to scene")
        }
    }
}
```

### 测试验证
- 控制台打印 "Root entity added to scene"

### 学习重点
- RealityView content 的 `add()` 方法
- 实体添加到场景

---

## 迭代 10: 创建第一个 3D 球体

### 目标
创建并显示第一个 3D 球体

### 修改文件
- `AppState.swift`

### 方法列表
1. `createTestSphere()` - 创建测试球体

### 代码要点

**AppState.swift**:
```swift
func setupContentEntity() {
    contentRoot.name = "ContentRoot"
    createTestSphere()
    print("Content entity setup complete")
}

private func createTestSphere() {
    // 创建球体网格
    let mesh = MeshResource.generateSphere(radius: 0.1)

    // 创建材质（绿色）
    let material = SimpleMaterial(
        color: .green,
        roughness: 0.2,
        isMetallic: true
    )

    // 创建模型实体
    let sphere = ModelEntity(
        mesh: mesh,
        materials: [material]
    )

    // 设置位置（在用户前方1米）
    sphere.position = [0, 1.5, -1]
    sphere.name = "TestSphere"

    // 添加到根实体
    contentRoot.addChild(sphere)

    print("Test sphere created at position: \(sphere.position)")
}
```

### 测试验证
- 进入沉浸式空间后，看到一个绿色的金属球体悬浮在前方

### 学习重点
- `MeshResource.generateSphere()` 创建球体网格
- `SimpleMaterial` 材质系统
- `ModelEntity` 模型实体
- 实体位置设置（position）
- 父子关系（addChild）
- visionOS 坐标系（y轴向上，z轴向前为负）

---

## 迭代 11: 添加多个不同颜色的球体

### 目标
创建多个球体，学习实体管理

### 修改文件
- `AppState.swift`

### 方法列表
1. `createColoredSphere(color:position:)` - 创建彩色球体
2. 修改 `setupContentEntity()` - 创建多个球体

### 代码要点

**AppState.swift**:
```swift
func setupContentEntity() {
    contentRoot.name = "ContentRoot"

    // 创建多个球体
    createColoredSphere(color: .red, position: [-0.3, 1.5, -1])
    createColoredSphere(color: .green, position: [0, 1.5, -1])
    createColoredSphere(color: .blue, position: [0.3, 1.5, -1])

    print("Content entity setup complete")
}

private func createColoredSphere(
    color: UIColor,
    position: SIMD3<Float>
) {
    let mesh = MeshResource.generateSphere(radius: 0.1)
    let material = SimpleMaterial(
        color: color,
        roughness: 0.2,
        isMetallic: true
    )

    let sphere = ModelEntity(mesh: mesh, materials: [material])
    sphere.position = position
    sphere.name = "Sphere_\(color.description)"

    contentRoot.addChild(sphere)
    print("Sphere created at \(position)")
}
```

### 测试验证
- 看到三个球体（红、绿、蓝）排成一排

### 学习重点
- 参数化方法创建实体
- `SIMD3<Float>` 向量类型
- 颜色参数传递

---

## 迭代 12: 添加球体存储字典

### 目标
使用字典管理球体，为后续删除功能做准备

### 修改文件
- `AppState.swift`

### 方法列表
1. 添加 `sphereEntities` 属性
2. 修改 `createColoredSphere` - 存储到字典

### 代码要点

**AppState.swift**:
```swift
@Observable
@MainActor
class AppState {
    var isImmersive = false
    let contentRoot = Entity()

    // 存储所有球体实体
    private(set) var sphereEntities: [UUID: ModelEntity] = [:]

    // ... 其他代码
}

private func createColoredSphere(
    color: UIColor,
    position: SIMD3<Float>
) {
    let mesh = MeshResource.generateSphere(radius: 0.1)
    let material = SimpleMaterial(
        color: color,
        roughness: 0.2,
        isMetallic: true
    )

    let sphere = ModelEntity(mesh: mesh, materials: [material])
    sphere.position = position

    let id = UUID()
    sphere.name = "Sphere_\(id)"

    contentRoot.addChild(sphere)
    sphereEntities[id] = sphere

    print("Sphere \(id) created at \(position)")
}
```

### 测试验证
- 功能与之前相同，但球体被存储到字典中

### 学习重点
- 使用 UUID 作为实体标识
- 字典存储实体引用
- `private(set)` 访问控制

---

# 阶段3: ARKit 世界跟踪

## 迭代 13: 添加 ARKitSession

### 目标
初始化 ARKit 会话，为空间跟踪做准备

### 修改文件
- `AppState.swift`

### 方法列表
1. 添加 `session` 属性
2. `initializeARKit()` - 初始化 ARKit

### 代码要点

**AppState.swift**:
```swift
import ARKit

@Observable
@MainActor
class AppState {
    var isImmersive = false
    let contentRoot = Entity()
    private(set) var sphereEntities: [UUID: ModelEntity] = [:]

    // ARKit session
    private let session = ARKitSession()

    init() {
        print("AppState initialized")
        setupContentEntity()
    }

    func initializeARKit() async {
        print("ARKit initialization started")
        // 后续迭代将添加具体逻辑
    }
}
```

### 测试验证
- 代码编译无错误

### 学习重点
- `ARKitSession` 类（visionOS 特有）
- 与 iOS 的 ARSession 的区别

---

## 迭代 14: 添加 WorldTrackingProvider

### 目标
添加世界跟踪提供者

### 修改文件
- `AppState.swift`

### 方法列表
1. 添加 `worldTracking` 属性
2. 修改 `initializeARKit()` - 启动世界跟踪

### 代码要点

**AppState.swift**:
```swift
@Observable
@MainActor
class AppState {
    // ... 其他属性

    private let session = ARKitSession()
    private let worldTracking = WorldTrackingProvider()

    // ... 其他代码
}

func initializeARKit() async {
    print("ARKit initialization started")

    do {
        try await session.run([worldTracking])
        print("ARKit session started successfully")
    } catch {
        print("ARKit session failed: \(error)")
    }
}
```

### 测试验证
- 需要在进入沉浸式空间时调用（下一迭代）

### 学习重点
- `WorldTrackingProvider` 类
- `session.run()` 启动跟踪
- async/await 错误处理

---

## 迭代 15: 在进入沉浸式空间时启动 ARKit

### 目标
在正确的时机启动 ARKit 会话

### 修改文件
- `ImmersiveView.swift`

### 方法列表
1. 添加 `.task` 修饰符启动 ARKit

### 代码要点

**ImmersiveView.swift**:
```swift
struct ImmersiveView: View {
    @Environment(AppState.self) private var appState

    var body: some View {
        RealityView { content in
            content.add(appState.contentRoot)
            print("Root entity added to scene")
        }
        .task {
            await appState.initializeARKit()
        }
    }
}
```

### 测试验证
- 进入沉浸式空间时，控制台显示 "ARKit session started successfully"
- 如果失败，需要检查权限

### 学习重点
- `.task` 修饰符的生命周期
- 异步初始化时机
- ARKit 会话管理

---

## 迭代 16: 添加 Info.plist 权限配置

### 目标
配置应用权限，允许使用世界感知

### 新建文件
- `Info.plist`（如果不存在）

### 方法列表
无（配置文件）

### 代码要点

**Info.plist**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSWorldSensingUsageDescription</key>
    <string>应用需要扫描房间以放置虚拟物体</string>
</dict>
</plist>
```

### 测试验证
- ARKit 会话能够成功启动
- 首次运行会提示权限请求

### 学习重点
- visionOS 权限系统
- `NSWorldSensingUsageDescription` 必需性
- Info.plist 配置

---

# 阶段4: 交互与放置

## 迭代 17: 添加预览球体显示状态

### 目标
添加控制预览球体显示的状态

### 修改文件
- `AppState.swift`

### 方法列表
1. 添加 `showPreviewSphere` 属性

### 代码要点

**AppState.swift**:
```swift
@Observable
@MainActor
class AppState {
    var isImmersive = false
    var showPreviewSphere = false  // 新增

    // ... 其他代码
}
```

### 测试验证
- 代码编译无错误

### 学习重点
- 布尔状态控制

---

## 迭代 18: 在 ContentView 添加"添加球体"按钮

### 目标
添加 UI 控件来触发预览球体

### 修改文件
- `ContentView.swift`

### 方法列表
1. 添加"添加球体"按钮

### 代码要点

**ContentView.swift**:
```swift
struct ContentView: View {
    @Environment(AppState.self) private var appState
    @Environment(\.openImmersiveSpace) private var openImmersiveSpace
    @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace

    var body: some View {
        VStack(spacing: 20) {
            Text("房间设计器")
                .font(.largeTitle)

            if !appState.isImmersive {
                Button("进入沉浸式空间") {
                    Task { await openImmersiveSpace() }
                }
                .buttonStyle(.borderedProminent)
            } else {
                VStack(spacing: 15) {
                    Button(appState.showPreviewSphere ? "取消放置" : "添加球体") {
                        appState.showPreviewSphere.toggle()
                    }
                    .buttonStyle(.borderedProminent)

                    Button("退出沉浸式空间") {
                        Task { await closeImmersiveSpace() }
                    }
                    .buttonStyle(.bordered)
                }
            }
        }
        .padding()
    }

    // ... 其他方法
}
```

### 测试验证
- 进入沉浸式空间后，看到"添加球体"按钮
- 点击后按钮文字变为"取消放置"

### 学习重点
- 条件渲染（if/else）
- 按钮状态动态变化
- `.toggle()` 方法

---

## 迭代 19: 创建预览球体实体

### 目标
创建跟随头部的预览球体

### 修改文件
- `ImmersiveView.swift`

### 方法列表
1. `createPreviewSphere()` - 创建预览球体

### 代码要点

**ImmersiveView.swift**:
```swift
struct ImmersiveView: View {
    @Environment(AppState.self) private var appState
    @State private var previewSphere: ModelEntity?

    var body: some View {
        RealityView { content in
            content.add(appState.contentRoot)

            // 创建预览球体
            let preview = createPreviewSphere()
            previewSphere = preview

            // 创建头部锚点
            let headAnchor = AnchorEntity(.head)
            headAnchor.addChild(preview)
            content.add(headAnchor)

            print("Preview sphere created")
        }
        .task {
            await appState.initializeARKit()
        }
    }

    private func createPreviewSphere() -> ModelEntity {
        let mesh = MeshResource.generateSphere(radius: 0.1)

        // 半透明灰色材质
        var material = SimpleMaterial()
        material.color = .init(
            tint: .gray.withAlphaComponent(0.5)
        )

        let sphere = ModelEntity(mesh: mesh, materials: [material])
        sphere.position = [0, 0, -1]  // 头部前方1米
        sphere.name = "PreviewSphere"
        sphere.isEnabled = false  // 初始隐藏

        return sphere
    }
}
```

### 测试验证
- 代码编译无错误
- 预览球体暂时不可见（isEnabled = false）

### 学习重点
- `AnchorEntity(.head)` 头部锚点
- 半透明材质创建
- `isEnabled` 控制可见性
- 相对于头部的位置

---

## 迭代 20: 根据状态显示/隐藏预览球体

### 目标
让预览球体响应状态变化

### 修改文件
- `ImmersiveView.swift`

### 方法列表
1. 添加 `.onChange` 监听状态

### 代码要点

**ImmersiveView.swift**:
```swift
var body: some View {
    RealityView { content in
        // ... 现有代码
    }
    .task {
        await appState.initializeARKit()
    }
    .onChange(of: appState.showPreviewSphere) { _, newValue in
        previewSphere?.isEnabled = newValue
        print("Preview sphere visible: \(newValue)")
    }
}
```

### 测试验证
- 点击"添加球体"按钮，预览球体出现在视野前方
- 点击"取消放置"，预览球体消失
- 球体跟随头部移动

### 学习重点
- `.onChange(of:)` 监听状态变化
- 实体可见性控制
- 头部锚定效果

---

## 迭代 21: 添加碰撞组件

### 目标
为预览球体添加碰撞检测，准备接收手势

### 修改文件
- `ImmersiveView.swift`

### 方法列表
1. 修改 `createPreviewSphere()` - 添加碰撞

### 代码要点

**ImmersiveView.swift**:
```swift
private func createPreviewSphere() -> ModelEntity {
    let mesh = MeshResource.generateSphere(radius: 0.1)

    var material = SimpleMaterial()
    material.color = .init(tint: .gray.withAlphaComponent(0.5))

    let sphere = ModelEntity(mesh: mesh, materials: [material])
    sphere.position = [0, 0, -1]
    sphere.name = "PreviewSphere"
    sphere.isEnabled = false

    // 添加碰撞形状
    sphere.generateCollisionShapes(recursive: false)

    // 添加输入目标组件（允许间接输入：视线+手势）
    sphere.components.set(
        InputTargetComponent(allowedInputTypes: [.indirect])
    )

    print("Preview sphere collision enabled")
    return sphere
}
```

### 测试验证
- 预览球体可以被视线"选中"

### 学习重点
- `generateCollisionShapes()` 生成碰撞体
- `InputTargetComponent` 输入组件
- `.indirect` 输入类型（视线+pinch 手势）

---

## 迭代 22: 添加点击手势放置球体

### 目标
实现点击预览球体放置实体的功能

### 修改文件
- `ImmersiveView.swift`
- `AppState.swift`

### 方法列表（ImmersiveView）
1. 添加 `.gesture()` 修饰符

### 方法列表（AppState）
2. `addSphereAtPosition(_:)` - 在指定位置添加球体

### 代码要点

**ImmersiveView.swift**:
```swift
var body: some View {
    RealityView { content in
        // ... 现有代码
    }
    .task {
        await appState.initializeARKit()
    }
    .onChange(of: appState.showPreviewSphere) { _, newValue in
        previewSphere?.isEnabled = newValue
    }
    .gesture(
        SpatialTapGesture()
            .targetedToAnyEntity()
            .onEnded { event in
                handleTap(event)
            }
    )
}

private func handleTap(_ event: EntityTargetValue<SpatialTapGesture.Value>) {
    guard let previewSphere,
          event.entity == previewSphere else {
        return
    }

    // 获取预览球体的世界位置
    let worldPosition = previewSphere.position(relativeTo: nil)

    // 在该位置创建球体
    appState.addSphereAtPosition(worldPosition)

    // 隐藏预览球体
    appState.showPreviewSphere = false
}
```

**AppState.swift**:
```swift
func addSphereAtPosition(_ position: SIMD3<Float>) {
    let mesh = MeshResource.generateSphere(radius: 0.1)
    let material = SimpleMaterial(
        color: .blue,
        roughness: 0.2,
        isMetallic: true
    )

    let sphere = ModelEntity(mesh: mesh, materials: [material])
    sphere.position = position

    let id = UUID()
    sphere.name = "Sphere_\(id)"

    contentRoot.addChild(sphere)
    sphereEntities[id] = sphere

    print("Sphere placed at \(position)")
}
```

### 测试验证
- 点击"添加球体"，预览球体出现
- 移动头部调整预览位置
- 用手势点击预览球体，在该位置创建蓝色球体
- 预览球体消失

### 学习重点
- `SpatialTapGesture` 空间点击手势
- `.targetedToAnyEntity()` 目标任意实体
- `position(relativeTo:)` 获取世界坐标
- 手势处理流程

---

## 迭代 23: 添加删除所有球体功能

### 目标
添加清除所有放置球体的功能

### 修改文件
- `AppState.swift`
- `ContentView.swift`

### 方法列表
1. `removeAllSpheres()` - 删除所有球体

### 代码要点

**AppState.swift**:
```swift
func removeAllSpheres() {
    for (id, sphere) in sphereEntities {
        sphere.removeFromParent()
        print("Sphere \(id) removed")
    }
    sphereEntities.removeAll()
    print("All spheres removed")
}
```

**ContentView.swift**:
```swift
VStack(spacing: 15) {
    Button(appState.showPreviewSphere ? "取消放置" : "添加球体") {
        appState.showPreviewSphere.toggle()
    }
    .buttonStyle(.borderedProminent)

    // 新增：删除按钮
    Button("删除所有球体") {
        appState.removeAllSpheres()
    }
    .buttonStyle(.bordered)
    .disabled(appState.sphereEntities.isEmpty)

    Button("退出沉浸式空间") {
        Task { await closeImmersiveSpace() }
    }
    .buttonStyle(.bordered)
}
```

### 测试验证
- 放置几个球体
- 点击"删除所有球体"，所有球体消失
- 按钮在没有球体时禁用

### 学习重点
- `removeFromParent()` 从场景移除
- 字典清空
- 按钮禁用状态（.disabled）

---

# 阶段5: 房间跟踪

## 迭代 24: 添加 RoomTrackingProvider

### 目标
添加房间跟踪提供者

### 修改文件
- `AppState.swift`

### 方法列表
1. 添加 `roomTracking` 属性
2. 修改 `initializeARKit()` - 同时启动房间跟踪

### 代码要点

**AppState.swift**:
```swift
@Observable
@MainActor
class AppState {
    // ... 其他属性

    private let session = ARKitSession()
    private let worldTracking = WorldTrackingProvider()
    private let roomTracking = RoomTrackingProvider()  // 新增

    // ... 其他代码
}

func initializeARKit() async {
    print("ARKit initialization started")

    do {
        // 同时运行世界跟踪和房间跟踪
        try await session.run([worldTracking, roomTracking])
        print("ARKit session started with room tracking")
    } catch {
        print("ARKit session failed: \(error)")
    }
}
```

### 测试验证
- 控制台显示 "ARKit session started with room tracking"

### 学习重点
- `RoomTrackingProvider` 类
- 同时运行多个 provider
- visionOS 房间跟踪能力

---

## 迭代 25: 添加房间锚点存储

### 目标
准备存储房间锚点数据

### 修改文件
- `AppState.swift`

### 方法列表
1. 添加 `roomAnchors` 属性
2. 添加 `roomRoot` 实体

### 代码要点

**AppState.swift**:
```swift
@Observable
@MainActor
class AppState {
    // ... 其他属性

    let contentRoot = Entity()
    let roomRoot = Entity()  // 新增：房间内容根节点

    private(set) var sphereEntities: [UUID: ModelEntity] = [:]
    private var roomAnchors: [UUID: RoomAnchor] = [:]  // 新增

    // ... 其他代码
}

func setupContentEntity() {
    contentRoot.name = "ContentRoot"
    roomRoot.name = "RoomRoot"

    // 将 roomRoot 添加到 contentRoot
    contentRoot.addChild(roomRoot)

    print("Content entities setup complete")
}
```

### 测试验证
- 代码编译无错误

### 学习重点
- 房间锚点字典
- 实体层级组织

---

## 迭代 26: 监听房间锚点更新

### 目标
创建异步任务监听房间变化

### 修改文件
- `AppState.swift`

### 方法列表
1. `processRoomUpdates()` - 处理房间更新

### 代码要点

**AppState.swift**:
```swift
func initializeARKit() async {
    print("ARKit initialization started")

    do {
        try await session.run([worldTracking, roomTracking])
        print("ARKit session started with room tracking")

        // 启动房间更新监听
        await processRoomUpdates()
    } catch {
        print("ARKit session failed: \(error)")
    }
}

private func processRoomUpdates() async {
    for await update in roomTracking.anchorUpdates {
        switch update.event {
        case .added:
            handleRoomAdded(update.anchor)
        case .updated:
            handleRoomUpdated(update.anchor)
        case .removed:
            handleRoomRemoved(update.anchor)
        }
    }
}

private func handleRoomAdded(_ anchor: RoomAnchor) {
    roomAnchors[anchor.id] = anchor
    print("Room added: \(anchor.id)")
}

private func handleRoomUpdated(_ anchor: RoomAnchor) {
    roomAnchors[anchor.id] = anchor
    print("Room updated: \(anchor.id)")
}

private func handleRoomRemoved(_ anchor: RoomAnchor) {
    roomAnchors.removeValue(forKey: anchor.id)
    print("Room removed: \(anchor.id)")
}
```

### 测试验证
- 进入沉浸式空间后，如果系统检测到房间，控制台会显示 "Room added"

### 学习重点
- `anchorUpdates` 异步序列
- 锚点事件（added/updated/removed）
- 房间锚点生命周期

---

## 迭代 27: 检测球体是否在当前房间

### 目标
根据球体是否在当前房间改变颜色

### 修改文件
- `AppState.swift`

### 方法列表
1. `isSphereInCurrentRoom(_:)` - 检查球体位置

### 代码要点

**AppState.swift**:
```swift
private func isSphereInCurrentRoom(
    position: SIMD3<Float>
) -> Bool {
    // 获取当前房间锚点
    guard let currentRoom = roomTracking.currentRoomAnchor else {
        print("No current room")
        return false
    }

    // 检查位置是否在房间内
    let isInRoom = currentRoom.contains(position)
    print("Position \(position) in room: \(isInRoom)")
    return isInRoom
}
```

### 测试验证
- 暂时无法直接测试（需要下一迭代应用）

### 学习重点
- `currentRoomAnchor` 获取当前房间
- `contains(_:)` 空间包含测试
- 房间边界检测

---

## 迭代 28: 根据房间位置改变球体颜色

### 目标
实现球体颜色自动变化（房间内绿色，房间外红色）

### 修改文件
- `AppState.swift`

### 方法列表
1. 修改 `addSphereAtPosition(_:)` - 根据位置设置颜色
2. `updateSphereColors()` - 更新所有球体颜色
3. 修改房间更新处理 - 触发颜色更新

### 代码要点

**AppState.swift**:
```swift
func addSphereAtPosition(_ position: SIMD3<Float>) {
    let mesh = MeshResource.generateSphere(radius: 0.1)

    // 根据是否在房间内选择颜色
    let isInRoom = isSphereInCurrentRoom(position: position)
    let color: UIColor = isInRoom ? .green : .red

    let material = SimpleMaterial(
        color: color,
        roughness: 0.2,
        isMetallic: true
    )

    let sphere = ModelEntity(mesh: mesh, materials: [material])
    sphere.position = position

    let id = UUID()
    sphere.name = "Sphere_\(id)"

    contentRoot.addChild(sphere)
    sphereEntities[id] = sphere

    print("Sphere placed at \(position), color: \(isInRoom ? "green" : "red")")
}

private func updateSphereColors() {
    for (_, sphere) in sphereEntities {
        let isInRoom = isSphereInCurrentRoom(position: sphere.position)
        let color: UIColor = isInRoom ? .green : .red

        let material = SimpleMaterial(
            color: color,
            roughness: 0.2,
            isMetallic: true
        )

        sphere.model?.materials = [material]
    }
    print("Sphere colors updated")
}

private func handleRoomUpdated(_ anchor: RoomAnchor) {
    roomAnchors[anchor.id] = anchor
    updateSphereColors()  // 房间更新时重新计算颜色
    print("Room updated: \(anchor.id)")
}
```

### 测试验证
- 在检测到的房间内放置球体，应为绿色
- 移动到房间外（如果可能），球体变为红色

### 学习重点
- 动态材质更新
- 房间边界感知
- 实体属性修改

---

# 阶段6: 高级功能

## 迭代 29: 添加墙面存储结构

### 目标
为墙面检测准备数据结构

### 修改文件
- `AppState.swift`

### 方法列表
1. 添加墙面相关属性

### 代码要点

**AppState.swift**:
```swift
@Observable
@MainActor
class AppState {
    // ... 其他属性

    let contentRoot = Entity()
    let roomRoot = Entity()
    let wallRoot = Entity()  // 新增：墙面根节点

    private(set) var sphereEntities: [UUID: ModelEntity] = [:]
    private var roomAnchors: [UUID: RoomAnchor] = [:]
    private var wallEntities: [String: ModelEntity] = [:]  // 新增

    // ... 其他代码
}

func setupContentEntity() {
    contentRoot.name = "ContentRoot"
    roomRoot.name = "RoomRoot"
    wallRoot.name = "WallRoot"

    contentRoot.addChild(roomRoot)
    contentRoot.addChild(wallRoot)

    print("Content entities setup complete")
}
```

### 测试验证
- 代码编译无错误

### 学习重点
- 墙面实体组织
- 多层级实体结构

---

## 迭代 30: 提取房间墙面几何

### 目标
从房间锚点中提取墙面几何数据

### 修改文件
- `AppState.swift`

### 方法列表
1. `extractWalls(from:)` - 提取墙面

### 代码要点

**AppState.swift**:
```swift
private func extractWalls(from roomAnchor: RoomAnchor) {
    // 清除旧墙面
    for (_, wall) in wallEntities {
        wall.removeFromParent()
    }
    wallEntities.removeAll()

    // 获取墙面几何
    let walls = roomAnchor.geometries(classifiedAs: .wall)

    print("Found \(walls.count) walls in room")

    for (index, wall) in walls.enumerated() {
        createWallEntity(
            from: wall,
            index: index,
            roomAnchor: roomAnchor
        )
    }
}

private func createWallEntity(
    from geometry: MeshAnchor.Geometry,
    index: Int,
    roomAnchor: RoomAnchor
) {
    // 下一迭代实现
    print("Wall \(index) detected")
}
```

### 测试验证
- 当检测到房间时，控制台显示墙面数量

### 学习重点
- `geometries(classifiedAs:)` 分类几何
- `.wall` 分类
- MeshAnchor.Geometry 类型

---

## 迭代 31: 将墙面几何转换为网格资源

### 目标
创建辅助方法将 ARKit 几何转换为 RealityKit 网格

### 新建文件
- `Extensions.swift`

### 方法列表
1. `MeshAnchor.Geometry.asMeshResource()` 扩展方法

### 代码要点

**Extensions.swift**:
```swift
import ARKit
import RealityKit

extension MeshAnchor.Geometry {
    @MainActor
    func asMeshResource() -> MeshResource? {
        // 获取顶点数据
        let vertices = self.vertices.asSIMD3(ofType: Float.self)

        // 获取面索引
        let faces = self.faces.asIndexArray()

        // 创建网格描述符
        var descriptor = MeshDescriptor()
        descriptor.positions = .init(vertices)
        descriptor.primitives = .triangles(faces)

        // 生成网格资源
        do {
            let mesh = try MeshResource.generate(from: [descriptor])
            return mesh
        } catch {
            print("Failed to generate mesh: \(error)")
            return nil
        }
    }
}

// 辅助扩展
extension GeometrySource {
    func asSIMD3<T>(ofType: T.Type) -> [SIMD3<T>] {
        var result: [SIMD3<T>] = []
        for i in 0..<count {
            let data = buffer.contents() + offset + (stride * i)
            let value = data.assumingMemoryBound(to: SIMD3<T>.self).pointee
            result.append(value)
        }
        return result
    }
}

extension GeometryElement {
    func asIndexArray() -> [UInt32] {
        var result: [UInt32] = []
        let indexCount = count * indexCountPerPrimitive

        for i in 0..<indexCount {
            let data = buffer.contents() + (i * bytesPerIndex)
            let index = data.assumingMemoryBound(to: UInt32.self).pointee
            result.append(index)
        }
        return result
    }
}
```

### 测试验证
- 代码编译无错误

### 学习重点
- ARKit 几何数据结构
- RealityKit MeshDescriptor
- 顶点和索引数据转换
- Swift 内存操作

---

## 迭代 32: 创建墙面实体并渲染

### 目标
将墙面几何转换为可视化实体

### 修改文件
- `AppState.swift`

### 方法列表
1. 实现 `createWallEntity(from:index:roomAnchor:)``

### 代码要点

**AppState.swift**:
```swift
private func createWallEntity(
    from geometry: MeshAnchor.Geometry,
    index: Int,
    roomAnchor: RoomAnchor
) {
    // 转换为网格资源
    guard let meshResource = geometry.asMeshResource() else {
        print("Failed to convert wall geometry")
        return
    }

    // 创建半透明蓝色材质
    var material = UnlitMaterial()
    material.color = .init(tint: .blue.withAlphaComponent(0.3))

    // 创建实体
    let wallEntity = ModelEntity(
        mesh: meshResource,
        materials: [material]
    )
    wallEntity.name = "Wall_\(index)"

    // 应用房间锚点的变换
    wallEntity.transform = Transform(matrix: roomAnchor.originFromAnchorTransform)

    // 添加到场景
    wallRoot.addChild(wallEntity)
    wallEntities["Wall_\(index)"] = wallEntity

    print("Wall \(index) entity created")
}
```

### 测试验证
- 在房间中，应该看到半透明蓝色的墙面轮廓

### 学习重点
- `UnlitMaterial` 无光照材质
- 半透明材质
- 变换矩阵应用
- 墙面可视化

---

## 迭代 33: 添加墙面可视化模式

### 目标
添加UI控制墙面显示/隐藏

### 修改文件
- `AppState.swift`
- `ContentView.swift`

### 方法列表
1. 添加 `showWalls` 属性
2. `toggleWallVisibility()` - 切换墙面显示

### 代码要点

**AppState.swift**:
```swift
@Observable
@MainActor
class AppState {
    var isImmersive = false
    var showPreviewSphere = false
    var showWalls = false  // 新增

    // ... 其他代码
}

func toggleWallVisibility() {
    showWalls.toggle()
    wallRoot.isEnabled = showWalls
    print("Walls visible: \(showWalls)")
}
```

**ContentView.swift**:
```swift
VStack(spacing: 15) {
    Button(appState.showPreviewSphere ? "取消放置" : "添加球体") {
        appState.showPreviewSphere.toggle()
    }
    .buttonStyle(.borderedProminent)

    // 新增：墙面显示切换
    Button(appState.showWalls ? "隐藏墙面" : "显示墙面") {
        appState.toggleWallVisibility()
    }
    .buttonStyle(.bordered)

    Button("删除所有球体") {
        appState.removeAllSpheres()
    }
    .buttonStyle(.bordered)
    .disabled(appState.sphereEntities.isEmpty)

    Button("退出沉浸式空间") {
        Task { await closeImmersiveSpace() }
    }
    .buttonStyle(.bordered)
}
```

### 测试验证
- 点击"显示墙面"按钮，墙面轮廓出现
- 点击"隐藏墙面"，墙面轮廓消失

### 学习重点
- 实体树的批量显示/隐藏
- UI 状态同步

---

## 迭代 34: 添加遮挡材质模式

### 目标
实现遮挡可视化，隐藏房间外的物体

### 修改文件
- `AppState.swift`

### 方法列表
1. 添加 `VisualizationMode` 枚举
2. `setVisualizationMode(_:)` - 设置可视化模式
3. 修改墙面创建逻辑

### 代码要点

**AppState.swift**:
```swift
enum VisualizationMode {
    case none      // 不显示
    case walls     // 显示墙面
    case occlusion // 遮挡模式
}

@Observable
@MainActor
class AppState {
    var isImmersive = false
    var showPreviewSphere = false
    var visualizationMode: VisualizationMode = .none  // 修改

    // ... 其他代码
}

func setVisualizationMode(_ mode: VisualizationMode) {
    visualizationMode = mode

    switch mode {
    case .none:
        roomRoot.isEnabled = false
        wallRoot.isEnabled = false
    case .walls:
        roomRoot.isEnabled = false
        wallRoot.isEnabled = true
    case .occlusion:
        roomRoot.isEnabled = true
        wallRoot.isEnabled = false
    }

    print("Visualization mode: \(mode)")
}
```

**修改房间处理**:
```swift
private func handleRoomAdded(_ anchor: RoomAnchor) {
    roomAnchors[anchor.id] = anchor
    extractWalls(from: anchor)

    // 创建遮挡实体
    if anchor.isCurrentRoom {
        createOcclusionEntity(from: anchor)
    }

    print("Room added: \(anchor.id)")
}

private func createOcclusionEntity(from roomAnchor: RoomAnchor) {
    // 简化版：使用房间的整体几何
    // 实际应该合并所有墙面几何
    let occlusionMaterial = OcclusionMaterial()

    // 后续可以创建完整的房间遮挡网格
    print("Occlusion entity created for room")
}
```

### 测试验证
- 切换不同的可视化模式

### 学习重点
- 枚举类型定义
- `OcclusionMaterial` 遮挡材质
- 模式切换逻辑

---

## 迭代 35: 添加可视化模式选择器

### 目标
在 UI 中添加模式选择器

### 修改文件
- `ContentView.swift`

### 方法列表
1. 添加 Picker 控件

### 代码要点

**ContentView.swift**:
```swift
VStack(spacing: 15) {
    Button(appState.showPreviewSphere ? "取消放置" : "添加球体") {
        appState.showPreviewSphere.toggle()
    }
    .buttonStyle(.borderedProminent)

    // 新增：可视化模式选择器
    Picker("可视化模式", selection: Binding(
        get: { appState.visualizationMode },
        set: { appState.setVisualizationMode($0) }
    )) {
        Text("无").tag(AppState.VisualizationMode.none)
        Text("墙面").tag(AppState.VisualizationMode.walls)
        Text("遮挡").tag(AppState.VisualizationMode.occlusion)
    }
    .pickerStyle(.segmented)

    Button("删除所有球体") {
        appState.removeAllSpheres()
    }
    .buttonStyle(.bordered)
    .disabled(appState.sphereEntities.isEmpty)

    Button("退出沉浸式空间") {
        Task { await closeImmersiveSpace() }
    }
    .buttonStyle(.bordered)
}
```

### 测试验证
- 使用分段选择器切换不同可视化模式

### 学习重点
- SwiftUI Picker 控件
- `.segmented` 样式
- Binding 双向绑定

---

# 阶段7: 优化与完善

## 迭代 36: 添加错误处理状态

### 目标
添加完善的错误处理

### 修改文件
- `AppState.swift`

### 方法列表
1. 添加 `ErrorState` 枚举
2. `checkAuthorization()` - 检查权限

### 代码要点

**AppState.swift**:
```swift
enum ErrorState: Equatable {
    case none
    case notSupported
    case notAuthorized
    case sessionError(String)
}

@Observable
@MainActor
class AppState {
    // ... 其他属性
    var errorState: ErrorState = .none

    // ... 其他代码
}

private func checkAuthorization() async -> Bool {
    let authorization = await ARKitSession().queryAuthorization(
        for: [.worldSensing]
    )

    if authorization[.worldSensing] == .denied {
        errorState = .notAuthorized
        return false
    }

    return true
}

func initializeARKit() async {
    print("ARKit initialization started")

    // 检查权限
    guard await checkAuthorization() else {
        print("Authorization denied")
        return
    }

    // 检查支持性
    guard WorldTrackingProvider.isSupported,
          RoomTrackingProvider.isSupported else {
        errorState = .notSupported
        print("Tracking not supported")
        return
    }

    do {
        try await session.run([worldTracking, roomTracking])
        errorState = .none
        print("ARKit session started successfully")

        await processRoomUpdates()
    } catch {
        errorState = .sessionError(error.localizedDescription)
        print("ARKit session failed: \(error)")
    }
}
```

### 测试验证
- 在不支持的设备上，显示相应错误

### 学习重点
- 权限查询
- 功能支持性检查
- 错误状态管理

---

## 迭代 37: 显示错误信息

### 目标
在 UI 中显示错误信息

### 修改文件
- `ContentView.swift`

### 方法列表
1. 添加错误视图

### 代码要点

**ContentView.swift**:
```swift
var body: some View {
    VStack(spacing: 20) {
        Text("房间设计器")
            .font(.largeTitle)

        // 错误信息显示
        if appState.errorState != .none {
            errorView
        }

        // 其他控件...
    }
    .padding()
}

@ViewBuilder
private var errorView: some View {
    VStack(spacing: 10) {
        Image(systemName: "exclamationmark.triangle.fill")
            .font(.largeTitle)
            .foregroundStyle(.red)

        switch appState.errorState {
        case .none:
            EmptyView()
        case .notSupported:
            Text("设备不支持房间跟踪")
        case .notAuthorized:
            Text("需要世界感知权限")
        case .sessionError(let message):
            Text("会话错误: \(message)")
        }
    }
    .padding()
    .background(.red.opacity(0.1))
    .cornerRadius(10)
}
```

### 测试验证
- 模拟错误状态，查看错误显示

### 学习重点
- `@ViewBuilder` 构建器
- switch 表达式匹配
- 条件视图渲染

---

## 迭代 38: 添加加载状态

### 目标
显示 ARKit 初始化进度

### 修改文件
- `AppState.swift`
- `ContentView.swift`

### 方法列表
1. 添加 `isInitializing` 属性
2. 添加加载指示器

### 代码要点

**AppState.swift**:
```swift
@Observable
@MainActor
class AppState {
    // ... 其他属性
    var isInitializing = false

    // ... 其他代码
}

func initializeARKit() async {
    isInitializing = true
    defer { isInitializing = false }

    print("ARKit initialization started")

    // ... 现有初始化代码
}
```

**ContentView.swift**:
```swift
if !appState.isImmersive {
    Button("进入沉浸式空间") {
        Task { await openImmersiveSpace() }
    }
    .buttonStyle(.borderedProminent)
} else {
    if appState.isInitializing {
        ProgressView("初始化中...")
    } else {
        // 现有控件
    }
}
```

### 测试验证
- 进入沉浸式空间时，短暂显示"初始化中..."

### 学习重点
- `defer` 语句
- `ProgressView` 控件
- 加载状态管理

---

## 迭代 39: 添加球体计数显示

### 目标
显示当前放置的球体数量

### 修改文件
- `ContentView.swift`

### 方法列表
1. 添加计数显示

### 代码要点

**ContentView.swift**:
```swift
VStack(spacing: 15) {
    // 球体计数
    HStack {
        Text("已放置球体:")
        Text("\(appState.sphereEntities.count)")
            .bold()
            .foregroundStyle(.blue)
    }
    .font(.headline)

    // 其他控件...
}
```

### 测试验证
- 放置球体后，计数增加
- 删除所有球体后，计数归零

### 学习重点
- 数据驱动 UI
- 计算属性显示

---

## 迭代 40: 添加使用说明

### 目标
创建简单的使用指南文档

### 新建文件
- `使用指南.md`

### 方法列表
无（文档）

### 代码要点

**使用指南.md**:
```markdown
# 房间设计器 - 使用指南

## 功能概述

这是一个 visionOS 空间设计应用，可以：
- 扫描和识别房间
- 在空间中放置 3D 物体
- 查看墙面和房间边界
- 区分房间内外的物体

## 使用步骤

### 1. 启动应用
- 运行应用后，会看到主窗口

### 2. 进入沉浸式空间
- 点击"进入沉浸式空间"按钮
- 等待 ARKit 初始化完成

### 3. 放置球体
- 点击"添加球体"按钮
- 半透明预览球体会出现在视野前方
- 移动头部调整位置
- 用手指做 pinch 手势点击预览球体
- 球体会被放置在该位置

### 4. 理解球体颜色
- 绿色球体：在当前检测到的房间内
- 红色球体：在房间外或未检测到房间

### 5. 查看墙面
- 使用可视化模式选择器：
  - **无**：不显示任何房间可视化
  - **墙面**：显示半透明蓝色墙面轮廓
  - **遮挡**：使用遮挡材质（房间外物体被隐藏）

### 6. 删除球体
- 点击"删除所有球体"清除所有放置的物体

### 7. 退出
- 点击"退出沉浸式空间"返回窗口模式

## 注意事项

- 需要授予世界感知权限
- 房间检测需要一定时间
- 在光线充足的环境中效果更好
- 移动设备可以帮助系统更好地理解空间

## 技术要求

- visionOS 1.0+
- Vision Pro 设备
- 世界感知权限
```

### 测试验证
- 阅读文档，确保说明清晰

### 学习重点
- 用户文档编写
- 功能说明

---

# 总结与下一步

## 完成的功能

经过 40 个迭代，我们实现了：

✅ visionOS 应用基础架构
✅ SwiftUI 窗口和沉浸式空间
✅ RealityKit 3D 内容渲染
✅ ARKit 世界跟踪
✅ ARKit 房间跟踪
✅ 空间手势交互
✅ 3D 物体放置
✅ 房间边界检测
✅ 墙面可视化
✅ 遮挡材质应用
✅ 错误处理
✅ 完整的 UI 控制

## 学到的技术

### visionOS 专有
- ImmersiveSpace
- RealityView
- AnchorEntity(.head)
- SpatialTapGesture

### ARKit for visionOS
- ARKitSession
- WorldTrackingProvider
- RoomTrackingProvider
- WorldAnchor / RoomAnchor

### RealityKit
- Entity 层级
- ModelEntity
- MeshResource
- SimpleMaterial / OcclusionMaterial / UnlitMaterial
- Component 系统

### SwiftUI
- @Observable
- @Environment
- 异步操作
- 状态管理

## 可选的后续迭代

如果想继续深入，可以添加：

### 功能扩展
- 物体移动（拖拽手势）
- 物体缩放和旋转
- 不同类型的 3D 模型
- 物体保存和加载（持久化）
- 多用户协作
- 物体吸附到墙面

### 交互优化
- 手部跟踪
- 眼动追踪选择
- 语音命令
- 更丰富的手势

### 视觉优化
- 更精细的材质
- 光照和阴影
- 粒子效果
- 动画

## 建议的学习路径

如果你是 visionOS 新手，建议按照以下顺序学习：

1. **基础迭代（1-6）**: 理解应用架构
2. **3D 内容（7-12）**: RealityKit 基础
3. **ARKit 集成（13-16）**: 空间跟踪
4. **交互（17-23）**: 手势和放置
5. **房间跟踪（24-28）**: 高级 ARKit
6. **可视化（29-35）**: 墙面和遮挡
7. **完善（36-40）**: 错误处理和优化

每完成一个阶段，确保：
- 运行并测试代码
- 理解每一行代码
- 能解释背后的原理
- 尝试小的变化和实验

---

**文档创建时间**: 2025-10-27
**版本**: 1.0
**迭代总数**: 40
**预计学习时间**: 20-30 小时（取决于现有经验）
